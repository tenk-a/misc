ＡＳ６３

	ＨＤ６３０９・クロス・アセンブラ	Version 1.20T



■  はじめに

    as63 は msdos で動作する 6809/6309 クロス・アセンブラです。
    以下のような特徴があります.

    ・いわゆるアブソリュート・アセンブラで、直接バイナリファイルかモトロー
      ラ s-format ファイルを生成します。
      つまり何がしかの .objファイルをつくってライブラリ化してリンカで後で
      リンクしてバイナリを生成、という高度なことはできません。
      （でも分割アセンブルを支援する仕組みが一応あります)
      もっとも(1997年)現在のパソコン環境(CPU,HDD)を思えば、毎回何十ものファ
      イルをinclude しまくってもたいしたことないように思える:)

    ・os9/6809 の標準 asm用のソースをアセンブルし、os9のモジュールを生成で
      きます.
      つまり、条件アセンブリはありますが、マクロは無しです。
      また、その範囲でos9/6809 用の microware-c の c.asmのソースを試しアセ
      ンブルできます（.rof ファイルを生成できるわけではありません）

    ・古えの富士通の８ビットパソコン, FM7/8/11のマシン語ファイルを生成でき
      ます:)

    ・このプログラムはＰＤＳとして配布されていたものを改造したものでこのプ
      ログラムもＰＤＳです。
      ソースがついているので、再コンパイルすれば MSDOS 以外でも動作する
      でしょう.



■  使いかた

□  as63 [-opts] SRC_FILE ...

    指定されたソースをアセンブルします。

    複数のファイルを指定すればそれらを一つながりのソースとしてアセンブルし
  ます。わかれたファイル間でのラベルの参照はグローバル・ラベル指定されたも
  ののみ有効で、そうでないラベルはファイル内でのみ参照可能です  （ただし、
  include されたファイルは include したファイルの１部として扱われます）。


□  オプション
    -?             ヘルプ
    -9             os9 標準 asm モード
    -8             6809 モード
    -s             シンボル・テーブル を表示
    -v             途中経過の表示
    -y             ロングブランチを可能ならショートブランチに置換(多パス)
    -q             org,rmb でアドレスが飛び飛びになるのを許す
    -m<mod_name>   $modnam 文字列変数を設定
    -d<LBL>[=Val]  ラベル LBL を値 Val で定義.  LBL: set Val(省略:1)
    -u             ラベルの大小文字を区別する
    -n             ラベルの大小文字を区別しない
    -l[lst_file]   アセンブリ・リストをlst_fileに出力
    -o[obj_file]   obj_file にオブジェクトをバイナリで出力
    -f[obj_file]   obj_file にオブジェクトを S-Format で出力
    -a[obj_file]   obj_file にオブジェクトを FCB のデータの形で出力
    -e[err_file]   err_file にソースのエラーを出力
    -i[lib_file]   $INC で参照するディレクトリ
    -k[Start[,Enter]]  F-BASIC マシン語ファイル形式で出力
    -r                 F-BASIC機械語ファイル形式時, rmbでその後にコードが
                       無ければ0を出力しない

  -o,-f,-a が同時に指定されると後で指定されたものが有効になります。
  -u,-n が同時に指定されると後で指定されたものが有効になります。
  -u,-n の指定のないときは -n が指定されたことになります。


□オプションの説明
  -?  -
      オプションのヘルプ・メッセージを表示。

  -l[lst_file]
      アセンブリ・リストを lst_file に出力します。
      lst_file の指定のない場合は標準出力します。

  -e[err_file]
      ソースに関するエラーメッセージを err_file に出力します。 err_file の
    指定のない場合はソースの拡張子を ".err" にして出力します。このオプシ
    ョンの指定がなかったときは標準エラー出力されます。

  -o[obj_file]
      obj_file にオブジェクトをバイナリで出力します。obj_file の指定のない
    場合はソースの拡張子を ".o" にして出力します。

  -f[obj_file]
      obj_file にオブジェクトを S-Format で出力します。obj_file の指定のな
    い場合はソースの拡張子を".s"にして出力します。

  -q
      このオプションの指定のないときは、 org や rmb によってアドレスに空き
    ができると $00 で埋めますが、このオプションが指定され、S-Format 出力で
    os9 モードでないときは、 S-Format に依存してアドレスが飛び飛びになるの
    を許します。

  -m<mod_name>
      fcc,fcsで利用できまる変数$modnamに文字列を設定します。

  -d<LBL>[=Val]
      ラベルLBLを値Valで定義します。値は10進数か16進数で指定します。
        -dLBL=$100 ->  LBL: set $100
        -dLBL      ->  LBL: set 1	値が省略されると1が設定されます。
 
  -i[lib_file]
      use(lib) で利用する変数$INCにディレクトリ名を設定します。

  -v
      途中経過の表示.

  -n
      ラベルの大小文字を区別しないようにします。

  -u
      ラベルの大小文字を区別するようにします。

  -y
      ロング・ブランチを可能ならショート・ブランチに置換するようにします。

  -s
      リスト表示のとき、ソースの後に、ラベル一覧を表示します。

  -8
      6309 の命令を使えないようにします。 チェックは不完全ですので、6309の
    命令を使われてもエラーにならない場合もあります。

  -9
      os9 Asm 用のソースをアセンブルするときに指定します。
      同時に-nオプションが設定されたことになります。

      org,rmbの扱いを os9 Asm と同じようにし、変数'.' を有効にします。

      アドレッシング・モードのチェックや mod,emod のあらわれる位置のチェッ
    クなどは手をぬいておこなってませんので、各自で気を付けてください。

      os9 Asm は次のような場合、
           leax LABEL,pcr
    たえず ロング・オフセットになりますが、as63 は可能ならショートになりま
    す。よって、同じソースでも違うオブジェクトになり、CRC があわなくなるば
    あいがあります。

      os9 Asm 用のソースをアセンブルするときは必ず指定してください。指定し
    なくてもエラーにならないこともありますが、期待したオブジェクトにならな
    いでしょう。

  -a[obj_file]
      .OBJ(.r)ファイルを出力できないので、その変わりとなるかもしれない機能
    です。

      グローバル・ラベル定義の行と未定義ラベルを使用した行はそのままの行で、
    その他のアセンブルできた行は  FCB データの形に変換したアセンブリ・ソー
    スを obj_file に出力します（つまり未定義ラベルはすべてグローバル・ラベ
    ル扱いです）。
      obj_file の指定のない場合はソースの拡張子を ".oa" にして出力します。

      ライブラリをつくる場合に、ファイルサイズを小さくするのとローカル・
    ラベルを減らすために用意しました。
    リロケータブルなサブルーチンを対象に考えていますのでリロケータブルでな
    いサブルーチンは不幸でしょう。
      また複数ファイルの指定を考えてないので、やると不都合があることでしょ
    う。

      あとで（ライブラリに）編集しなおすのを前提にしていますので出力をその
    ままま再アセンブルするのも不幸です。思い当る点としては、

    ・未定義ラベルのある行をそのまま出力するため、同じ行にある未定義でなか
      ったラベルも数値に変換されずそのままです。

    ・グローバル・ラベル定義の行に未定義ラベルを使用した場合, その行はだ
      ぶって出力されてしまいます。

    ・行末の不要なコメントは削除されません。

    あと、未定義ラベルを含む命令は必ず強制 16 ビット指定の '>' か強制 8 ビ
    ット指定の '<' を付けましょう。 でないとオブジェクトサイズが変化するこ
    とおおありです。

  -k[Start[,Enter]]
      F-BASIC機械語ファイル形式で出力します。

      生成するオブジェクトの頭に、
	  $00				(1バイト),
	  オブジェクト・サイズ		(2バイト)
	  Start(ロード・アドレス)	(2バイト)
    の5バイトを付加し、オブジェクトの後に、
	  $FF,$00,$00			(3バイト)
	  Enter(実行開始アドレス)	(2バイト)
	  $1a				(1バイト)
    の6バイトを付加します。

      Start が省略された場合は、 最初に org で指定されたアドレスになりま
    す。orgでの指定のない場合は、0 になります。
      Entry が省略された場合は、 end で指定されたアドレスになります。end
    での指定もない場合は Start と同じになります。

  -r
    -k指定のF-BASIC機械語ファイル形式時, ソース中にrmbがありその後にコードが
    無ければrmbの 0を出力しません。


■  定数式

□  定数
    10進数は数字ではじまり数字がならんだもの。

    16進数は '$' ではじまり、'0'〜'9', 'A'〜'F' が並んだもの（大小文字の区
    別無）。

    2進数は '%' ではじまり、'0', '1' がならんだもの。

    ｢'｣に続く1文字の値（文字コード：シフトＪＩＳ文字に対応）。

    ｢"｣ に続く2文字(2バイト)。1バイト目を上位, 2バイト目を下位とする。
    （os9 Asm で非公式(?)にサポートされてる機能です。昔のザベで紹介されて
      ました。）

□  ラベル
    'A'〜'Z' 'a'〜'z' '_' '.'
  で始まり、
    'A'〜'Z' 'a'〜'z' '0'〜'9' '_' '.' '@' '$' '@'
  が並ぶ名前。（とりあえず21文字まで有効にしてあります）

□  ラベル定義
    行頭に空白を空けずにラベル名が書かれればそのアドレスを値とするラベルが
  定義されます。

    また、equ,set 疑似命令や csect〜endsect, os9 モード時の org 疑似命令で
  アドレス以外の値を設定することができます。

    ラベル名の後に ':' をつけて定義した名前は グローバル・ラベル名となり別
  のファイルでも参照できるようになります。':' を付けずに定義したラベル名は
  ファイル内でのみ有効です。
    ローカルラベルを含めラベル名は指定されたファイルすべてのものを一度に登
  録し、ラベルの数だけメモリを食います。ファイル間のローカル・ラベルの衝突
  をさけるために用意しただけですので...。


□  定数演算
    式は 2バイト負号付き整数で計算され、式の途中に空白を置けません。

    演算子には以下のようなものがあり、上の段ほど先に評価され、同じ段のもの
  なら先に表れたものが先に評価されます。
     1.単項-  単項!  単項~  単項^  (式)  変数*  変数.  used()  defined()
     2. *  /  %
     3. +  -
     4. >>  <<
     5. >  >=  <  <=
     6. ==  !=  
     7. &
     8. ^  ?
     9. |  !
    10. &&
    11. ||

    基本的にＣの演算子と同じです。
    変数 '.'・単項 '^'・二項 '!'・二項演算子 '?' は、 os9 Asm との互換性の
  ためにあります。Ｃのものを基本としてますので、os9 Asm のソースをアセンブ
  ルする以外ではつかわないほうが無難です。  （とくに、'?' は非公式の演算子
  (昔のザベで紹介されてたもの) で使われてることはまあなさそだし、もし Ｃの
  三項演算子 '?' をサポートするようなことがあれば、衝突してしまうので）

  動作は以下のようになります（LBLをラベル名、X,Yを定数(式)とする）
    ・*     演算子でなく、その命令の置かれるアドレスを値とします。
    ・.     os9 Asm モードのときのみ有効で、org,rmbで得られる値の現在値｡
    ・-X    負号反転
    ・!X    X が 0 のとき 1、X が 0 でなけらば 0
    ・~X    Xの各ビットを反転
    ・^X    Xの各ビットを反転  (os9 Asm)
    ・(式)  ()内を先に計算
    ・defined(LBL)  LBLがソースのどこかで定義されていれば1, でなければ 0
    ・used(LBL)     ソース中で使われたり定義されていれば1,でなければ 0
    ・X*Y   乗算
    ・X/Y   除算
    ・X%Y   余算
    ・X+Y   加算
    ・X-Y   減算
    ・X&Y   ビットごとの論理積
    ・X^Y   ビットごとの排他的論理和
    ・X?Y   ビットごとの排他的論理和  (os9 Asm)
    ・X|Y   ビットごとの論理和
    ・X!Y   ビットごとの論理和  (os9 Asm )
    ・X>>Y  右シフト
    ・X<<Y  左シフト
    ・X==Y  等しいければ 1, そうでなければ 0
    ・X!=Y  等しくなければ 1, そうでなければ 0
    ・X>Y   大きければ 1, そうでなければ 0
    ・X>=Y  大きいか等しくなければ 1, そうでなければ 0
    ・X<Y   小さければ 1, そうでなければ 0
    ・X<=Y  小さいか等しくなければ 1, そうでなければ 0
    ・X&&Y  X,Yともに 0 でなければ 1, そうでなければ 0
    ・X||Y  X,Yともに 0 ならば 0, そうでなければ 1

□  used()
      used(LBL) はソース中のどこかでラベル LBL が 定義されるか使われるかす
    ると 1 を、そうでなければ 0 を値とします。used(LBL) を実現するため, パ
    ス１で現れるラベル名はすべて登録しています（used() や defined()で 指定
    するラベルはもちろん登録されません）。

     |          :  (1)
     |       if  used(LBL)
     |LBL       :  (2)
     | 	        :
     |       endif
     |       	:  (3)

     (1) の範囲で LBL が使われる（たとえば lbsr LBL）と条件が成立し, LBLを
    定義したルーチンが現れ生成されます。LBL が (1), (3) で使われていなけれ
    ば 条件は成立せず、それに関して何も生成しません。used() はこのような使
    い方を考えて用意しました。
      が問題があり、(1)で使われず(3)で使われた場合、パス1 では条件が成立
    せず (2) は生成しませんが、２回目以後のパスからは条件が成立してしまい、
    (2) が生成されることになります。もちろん、オブジェクトが生成されれば矛
    盾が生じエラーとなりますが、(2) がラベル定義や変更だけだとわからないば
    あいがありえます。

      defined() も used() と同じように、 if defined(LBL) としたとき、LBLが
    条件文より後で定義されていると、パス１とそれ以降で条件が変わってしまう
    ので気をつけてください。



■  条件付アセンブル
    式の値によって、アセンブルする部分を条件分けできます。

    ・式 が 0でなければ (命令群) を アセンブルし、0 ならばしない。
      if  式
	(命令群)
      endif

    ・式 が 0でなければ (命令群1) を アセンブルし、0 ならば (命令群2)をア
      センブルする。
      if  式
	(命令群1)
      else
	(命令群2)
      endif

    ・式 が 0 でなければ (命令群1) をアセンブルし、0 ならば次のelsifの式を
      評価し、0 でなけらば(命令群2) を、 そうでなければ (命令群3) をアセン
      ブルする。（elsif 節は else か endif が現れるまでいくつもおける）
      if  式
	(命令群1)
      elsif 式
	(命令群2)
      else
	(命令群3)
      endif

  また、os9 Asm  との互換性のため 以下のものもあります。
    ・ifne 式	式の値が 0 以外のときアセンブル
    ・ifeq 式	式の値が 0 のときアセンブル
    ・iflt 式	式の値が 0 未満のときアセンブル
    ・ifle 式	式の値が 0 以下のときアセンブル
    ・ifgt 式	式の値が 0 より大きいときアセンブル
    ・ifge 式	式の値が 0 以上のときアセンブル
    ・ifp1      パス1のときのみアセンブル （おもに定数ラベル登録用）
    ・endc	endif と同じ



■  疑似命令

□  end  [式]
    ソースの終わりを示します。 [式] は省略可能で、エントリーアドレスを示し
  ます。S-Format 出力のときや F-Basic マシン語ファイル出力のときのみ意味を
  もちます。

□  <LABEL> equ  <式>
    ラベル<LABEL>に<式>の値を割り当てます。
  ソース中、同じラベルに対して1度だけ行え、2度以上行うことはできません。

□  <LABEL> set  <式>
    ラベル<LABEL>に<式>の値を割り当てます。
  equ と違い、同じラベルに対して何度も値を設定しなおせますが、前方参照をす
  ると値が不安定です。

□  csect <式>  〜  endsect
    連続するラベルを定義するのに使います。
    csect 〜 endsect の間には rmb 以外の命令は置けず、<式>の値から始まり、
  rmbのサイズごとに値を更新します。なお、<式> は省略不可です。
  たとえば、
		csect	0
      LBL1	rmb	1
      LBL2	rmb	10
		rmb	2
      LBL3	rmb	0
		endsect
  は、
      LBL1	equ	0
      LBL2	equ	1
      LBL3	equ	13
  と同じことになります。

□  org  <式>
  ＊  os9 モードでない場合
    アセンブラの生成するオブジェクトのアドレスを<式>に変更します。
    S-Format 出力でない場合に org を複数指定するときは、指定するアドレスは
  org 実行前のアドレスよりも高いアドレスでないといけません。指定が有効なば
  あいは空いたアドレスの分だけ $00 が出力されます。

    S-Format 出力の場合は S-Format の仕様に依存できるので、-q オプションが
  指定してあれば、空いた部分を $00 で埋めるようなことはしません。

  ＊  os9モードの場合
    org はオブジェクトのアドレスとは関係なく、 csect と同じように rmb を用
  いて連続するラベルを定義するのに利用されます。csect とは違い、ソース中の
  すべてのrmbに影響します。

□  rmb  <式>
  ＊ os9 モードでない場合
    <式> のバイト数分、データ領域を確保するのに使います。
    S-Format 出力でない場合、 領域を確保するために 領域分の $00 を生成しま
  すが、S-Format出力の場合は S-Format の仕様に依存できるので -q オプション
  が指定してあればオブジェクトは生成しません。
    基本的にはデータ領域の初期化は行われないことになっているので、 $00で埋
  められた領域を生成したい場合は rzb を使ってください。

  ＊ os9モードの場合や、csect 〜 endsectに囲まれている場合
    連続する定数ラベルを定義するのに使います。

□  rzb  <式>
  <式>のバイト数分、$00を生成します。

□  fcb  <式> {,<式>}
    <式> の値を 1 バイトのデータとしてコンマで区切られた分だけ生成します。
    <式> は 1 バイトの範囲に納まらないといけませが、 データの頭に '>' を付
  ければ 2 バイトデータが生成できます。
    もし 式の代わりに '"' で囲まれた文字列があれば、それをデータとして生成
  します。

□  fdb  <式> {,<式>}
    <式>の値を2バイトのデータとしてコンマで区切られた分だけ生成します。

□  fcc  "文字列" {,"文字列"}
□  fcs  "文字列" {,"文字列"}
    デリミタでかこまれた文字列を生成します。
    fcs のほうは、 os9 のモジュール名やファイル名のために bit 7 を強制的に
  セットした文字列を生成します（漢字未対応）。
    デリミタは２つとも同じ文字であり、文字列中に含まれてはいけません。
    デリミタとして主に以下のものが使えます（他にも使える文字がある^^;）。

	"  /   '  #  !  -  +  *  &

  実際には最初の3つ以外はなるべく使わないほうが無難だと思います。

    fcc,fcs でのみ有効な変数として $modnam が使えます。-m で指定されていれ
  ば指定された名前を、指定のない場合はソースファイル名からディレクトリ名
  と拡張子を除いた名前を文字列として生成します。

    あと制限付きですが、文字列以外にも式を指定することができます。
    ラベル名、数字、'$'、'%'、'(' の何れかで始まる場合式と解釈し、fcb と
  同じように１バイトのデータを生成します。
    fcs もそうなのですが、区切られた文字列ごとに文字列の最後の文字のビット
  ７がセットされ、また式の値に対しては影響しません。

□  lib     ファイル名
□  use     ファイル名
□  include ファイル名
    指定されたファイルよりソースを読み込みます。
  ファイル名の頭（ディレクトリ名）が $INC なら設定されたディレクトリ名に置
  換してそのファイルを読み込みます（'INC'は大文字）。 （ファイル名の途中に
  ある場合は認識しません）

□  opt  {-l|l}
    ソース中でオプションを変更します。いまのとこ、以下のものしか対応してま
  せん。これ以外のものは無視します。（エラーにはなりません）
    opt  l	ソースを表示します。    
    opt  -l	ソースの表示を抑制します。
		正確には内部のカウンタを l が指定されれば +1, -l なら -1し
		て、カウンタの値がが 0 より大きければ表示、0以下なら抑制し
		ます（os9 Asm と同じはずです）。

□  無視する疑似命令
    以下の命令はサポートされていませんが、ソースにあらわれてもエラーにはな
  りません。
      vsect,psect, spc, nam, ttl, pag, fail

    このうち vsect,psect,fail は c.asm 命令なので、c.asmのソースをちゃんと
  生成することはできませんが、ためしにアセンブルするくらいはできるかもしれ
  ません。



■  ニーモニック

    一応、別ファイルで命令一覧を付属しますが、詳しくは 6809 の命令は 6809 
  関係の書籍を参考にしてください。6309 独自の命令は、NIFTY OS9フォーラム(FOS9)
  の DL にあるドキュメントや 'Oh! FM 1988 4月号'、'I/O別冊6809活用研究' をみ
  てください(^_^;)。
  
  以下は この as63 固有の都合です。


□  ???_iでのイミディエイト指定
    ??? を #イミディエイト指定可能な命令とするとき、
      ???    #定数式	( ldw  #10 )
    を
      ???_i  定数式	( ldw_i 10 )
    のように c.asm 用 6309 マクロでの表記もできます。

□  ldq のイミディエイト・アドレッシング
    ldq のイミディエイト・アドレッシングは、
      ldq  #H,L   (H:上位２バイト  L:下位２バイト  定数式)
    ですが、指定する値が２バイト符号付整数の範囲なら
      ldq  #L
    というふうに 'H,' の部分を省略でき、 H の部分は L を符号拡張して得られ
    たものが設定されます（0 または $FFFF)。
    ２バイト符号付整数の範囲外のとき（たとえば $8000 や$ fd00 など）は値が
    不安定ですので省略せずに指定してください。

□  ロング・ブランチでの強制ロング指定
    ロング・ブランチは -y オプションにより可能なものをショートにできますが、
  このときショートに変更したらこまるラベルに対してラベルの頭に'>' を付けれ
  ばショートに変更できるときでも変更しなくなります。（ex:  lbra >InitTbl）


□  合成命令
    合成命令として以下のものがあります。

  ・ニーモニックのみの命令
    （フラグ変化  * 変化  X 破壊  ･ 不変  1 set   0 clr）
		(生成される命令)	    NZVC	サイズ
	negw	comw;incw		    **X1	 4
	lslw	andcc #$fe;rolw		    ****	 4
	asrw	pshw;asl ,s++;rorw	    **X*	 6

	tstq	stq -4,s		    **･･	 3
	clrq	clrw;clrd		    0100	 4
	comq	comw;comd		    *X01	 4
	negq	comd;comw;incw;bne*+4;incd  *XX1	10
	lsrq	lsrd;rorw		    XX･*	 4
	asrq	asrd;rorw		    XX･*	 4
	rorq	rord;rorw		    XX･*	 4
	rolq	rolw;rold		    *XX*	 4
	lslq	andcc #$fe;rolw;rold	    *XX*	 6
	incq	incw;bne *+4;incd	    *XX･	 6
	decq	tstw;bne *+4;decd;decw	    *X0･	 8

      スピードよりもサイズが小さいことを優先しました。

      decq は c フラブを変化させたくなかったのでこうしましたが、スピードは
      addq #1(addw #1;adcd #0) のほうが速いです（サイズは変わらず)。

  ・addq,subq
      可能なアドレッシング・モード
	イミディエイト
	エクステンド
	ダイレクト($00〜$fd まで)
	ゼロ,5ビット(x,y,u,s),
	8ビット,16ビット(x,y,u,s,pc,pcr)
	オート・インクリメント、オート・デクリメント

      不可能なアドレッシング・モード
	インダイレクト・モード
	レジスタ・オフセット
	Wレジスタによるインデックス

  ・psh,pul
      psh,pul で w レジスタを指定できます。
      指定された場合、w がスタック・トップになるようにつまれます。
      pshs w なら pshsw、
      pulu w なら puluw、
      pshu w,d,x,y なら、pshu d,x,y;pshuw、
      puls w,d,x,y,pc なら pulsw;puls d,x,y,pc
      となります。


□  6809モード時の合成命令
    6809モードにおいて以下の命令は6809で生成することができます。

  ・ニーモニックのみの命令
	(生成される命令)		NZVC	6309との互換性	(サイズ)
	clrd	clrb;clra		0100	n,z,v,c有効	2    同じ
	tstd	std  -2,s		**0･	n,z,v,c有効	2    同じ
	comd	comb;coma		*X01	n,c有効		2    同じ
	negd	nega;negb;sbca #0       *XXX	n有効		4    違う
	incd	addd #1			****	n,z,v有効	3    違う
	decd	subd #1			****	n,z,v有効	3    違う
	asld	lslb;rola		*XX*	n,c有効		2    同じ
	lsld	lslb;rola		*XX*	n,c有効		2    同じ
	rold	rolb;rola		*XX*	n,c有効		2    同じ
	asrd	asra;rorb		XX･*	v,c有効		2    同じ
	lsrd	lsra;rorb		XX･*	v,c有効		2    同じ
	rord	rora;rorb		XX･*	v,c有効		2    同じ

  ・adcd,sbcd,andd,ord,eord
      可能なアドレッシング・モード
	イミディエイト
	エクステンド
	ダイレクト($00〜$feまで)
	ゼロ,5ビット(x,y,u,s)
	8ビット, 16ビット(x,y,u,s,pc,pcr)
	オート・インクリメント、オート・デクリメント。

      不可能なアドレッシング・モード
	インダイレクト・モード
	レジスタ・オフセット

    レジスタに対する動作が同じなだけでフラグ変化や生成されるサイズは異なり
    ますので気をつけて使ってください。



■  こまごま

□ 配布条件等

      改造もとソースは Nifty-Serve OS9フォーラムで配布されていたGigo氏
    作の as63 で、さらにこのプログラムは Masataka Ohta, Hiroshi Tezuka
    両氏のPDSの6809アセンブラ AS09 を参考にしたものらしいです。
      ということで、この as63 もPDSなので、ソースの配布、改造は自由です。

      なお、コンパイルは lsi-c86試食版を用いています。
      ので、厳密には実行ファイル(as63.exe)自体は、lsi-c86試食版での配布
    条件に従いフリーソフトとなります（詳しくは lsi-c86の配布条件をみて
    ください。営利使用は不可だったはずです...まあ再コンパイルしてね、っと）

    とりあえず、ぼくが改造のもとにした ソースの DL の補足説明と、AS09 
    に入ってたコピーライトのファイルを写しときます （正確には AS09 の
    ファイルでは PDS という言葉は使われてませんが...コピーライトがこの
    ようになっているのであえて PDS という言葉を使っています）。

    --- Gigo師作の as63 ----------------------------------------------
    データ名：as63(use ish & ar 3.x)
          ID：PAH00712
    登録日付：89/10/21
        属性：テキスト
      バイト：17353
        参照：23
    補足説明
      OS9のモジュールも、ROFも出力出来ない「普通の」6309対応
    アセンブラです。ソースだけですのでCコンパイラが必要です。

      このままでは、subsystemの改良ぐらいしか使い道がありませ
    ん。なお、UnixやMS−DOSでもそのままコンパイル出来ます。

                                        from  Gigo
    ------------------------------------------------------------------
    --- AS09 のcopyright ファイルより --------------------------------
    COPYRIGHT (c) 1981, 1987 Masataka Ohta, Hiroshi Tezuka

    No rights reserved. Everyone is permitted to do anything
    on this program including copying, transplanting,
    debugging, and modifying.
    ------------------------------------------------------------------



□ 改造内容

    Gigo氏のオリジナルからの変更点は以下のとおりです.

    1.  Sフォーマット・ファイルだけでなく、バイナリでの出力もできる。
    2.  定数演算の強化（Cのものに似せた）。
    3.  条件付アセンブル機能を付加。
    4.  csect,endsect,rzb の実装。
    5.  OS9付属Asm のソースをアセンブルできるように改造
        set, mod, emod, fcs の追加, org,rmb の対応 etc...
          emod での crc 計算は osk 用 6309 クロス・アセンブラ asm6309
          の C のソースの crc9 ルーチンを写させていただきました^^;
    6.  FBasic 機械語ファイルを出力可。
    7.  複数のファイルを指定すればそれらを一つながりのソースとしてアセ
        ンブルするが、わかれたファイルごとにローカル・ラベルを使えるよ
        うにした。
    8.  defined(LBL), used(LBL) という関数を条件付アセンブル機能ととも
        につかえばライブラリ(もどき)がなんとかつくれる(はず..)
    9.  グローバル・ラベル定義の行と未定義ラベルを使用した行はそのまま
        の行で、その他のアセンブル できた行は FCB のデータの形に変換し
        たアセンブリ・ソースを出力できるようにした。
    10. それらしい合成命令を付加(comq,やaddqなど...)
    11. etc

    問題は改造してみただけで使ってないってことです... でもって、チェッ
    クらしいチェックをしてないので大きい虫が必ずいることでしょう.
    1-5 までの改造は os9 asm 用のソースをアセンブルして crc があってい
    ればまず大丈夫だろうとおもうのですが、その他は簡単な確認さえやって
    いないものもあり、かなり妖しいでしょう。 あっと Sformat 出力もあや
    しいです。だから使ってくれる奇特な方は使って虫をだしてください。で
    もって、修正していだだけるともっといいです^_^.

   あと, ぼくが配布したv1.11Tのあと, あき氏によってF-BASIC機械語ファイル
   生成での不都合部分(-r関係の追加)、および MS-C v5 での再コンパイル用の
   手直しをされた v1.12Ta が NIFTY の FFMHOB にアップロードされています。


□ 再コンパイル

    ANSI-C でならばたいてい再コンパイルできるとおもいます。
    ただし、int は 16ビットが前提で、 int が32ビットの場合再コンパイル
    すると ldq #$12345678 とかがちゃんと機能しちゃうでせう:)

    as63 v1.12Ta まではK&Rスタイルのソースですが, もはやos9/09 上で
    コンパイルすることもないだろうし他の参考の可能性を思うと ANSI-C の
    ほうがまだいいかな（というよりすでに自分が old-c にたえられない^^;)
    と思い、os9の都合の部分を手直ししました。
　　（T.Kobayashi氏の kran を活用)

    あと char はコンパイルオプションで unsigned 扱いにしたほうが安全でせう.


□  as63 遍歴
    (1981-1987 AS09  6809/6800クロス・アセンブラ  for UNIX,FLEX)
    (                Masataka Ohta, Hiroshi Tezuka)
    1988       AS63 ver 1.00 6309クロス・アセンブラ for OS9,MSDOS,UNIX
                     Gigo
    1991-1992  AS63 ver 1.11T  for OS9,MSDOS
                     M.Kitamura(てんか☆ふん)
                     OS9asm互換化等
    1992       AS63 ver 1.12Ta for MSDOS
                     あき
                     MS-Cへの対応とF-BASIC機械語ファイル用変更
    1997       AS63 ver 1.20T  for MSDOS
                     M.Kitamura(てんか☆)
                     ソースの ANSI-C 化. !=,==の優先順位の手直し.



■  おわりに

    なんかいまさらなんですが。
    ほんのちょっと気になっていた ==,!= の優先順位がＣと違っていたのを
    ちょこっと修正しただけですが、ついでに K&R に絶えられず ANSI-C 化
    してしまったと. os9での再コンパイルのため複数ファイルにソース分割
    してたのもその必要なくなったのでくっ付けなおしました。ドキュメント
    もreadme.txtとas63.docだったのをas63.txt一つにまとめちゃいました.

    と。
    v1.11T弄ってたのってもう５年前. まだ学生だったなあ. 
    以後、心には09と深く刻まれてるけど、たまに資料とかぱらぱらするけど
    実際にはos9も6809もすることなく... 

    as63弄りついでに、ひさしぶりに NIFTYの os9フォーラムに行こうとした
    ら...巡回しない...どうやら無くなってる！？(T T)

    ああああああああああああああああああ

    後悔先に立たず。もっとまめに見に行っとくんだった(T T)
    独学でプログラミングを覚えたぼくにとってos9自身やfos9で得られたもの
    ははかりしれず...
    秀和のos9解析本やOh!FM読んで os9を理解できたと思えた瞬間があるから、
    as63やmicro-c, MIYAZAKI師匠のエディタ達, その他 unix流の小回りの利く
    ツール群のソースを読み理解できたと思えた瞬間があるから今の自分があ
    る...うぅ...


                                                    てんか☆(M.Kitamura)
